"""
This type stub file was generated by pyright.
"""

from django.db import models
from django.utils.functional import cached_property
from rest_framework.compat import postgres_fields
from rest_framework.fields import ChoiceField, Field
from rest_framework.relations import HyperlinkedIdentityField, HyperlinkedRelatedField, PrimaryKeyRelatedField, SlugRelatedField

"""
Serializers and ModelSerializers are similar to Forms and ModelForms.
Unlike forms, they are not constrained to dealing with HTML output, and
form encoded input.

Serialization in REST framework is a two-phase process:

1. Serializers marshal between complex types like model instances, and
python primitives.
2. The process of marshalling between python primitives and request and
response content is handled by parsers and renderers.
"""
LIST_SERIALIZER_KWARGS = ...
LIST_SERIALIZER_KWARGS_REMOVE = ...
ALL_FIELDS = ...
class BaseSerializer(Field):
    """
    The BaseSerializer class provides a minimal class which may be used
    for writing custom serializer implementations.

    Note that we strongly restrict the ordering of operations/properties
    that may be used on the serializer in order to enforce correct usage.

    In particular, if a `data=` argument is passed then:

    .is_valid() - Available.
    .initial_data - Available.
    .validated_data - Only available after calling `is_valid()`
    .errors - Only available after calling `is_valid()`
    .data - Only available after calling `is_valid()`

    If a `data=` argument is not passed then:

    .is_valid() - Not available.
    .initial_data - Not available.
    .validated_data - Not available.
    .errors - Not available.
    .data - Available.
    """
    def __init__(self, instance=..., data=..., **kwargs) -> None:
        ...
    
    def __new__(cls, *args, **kwargs): # -> ListSerializer | Any | Self:
        ...
    
    def __class_getitem__(cls, *args, **kwargs): # -> type[Self]:
        ...
    
    @classmethod
    def many_init(cls, *args, **kwargs): # -> ListSerializer | Any:
        """
        This method implements the creation of a `ListSerializer` parent
        class when `many=True` is used. You can customize it if you need to
        control which keyword arguments are passed to the parent, and
        which are passed to the child.

        Note that we're over-cautious in passing most arguments to both parent
        and child classes in order to try to cover the general case. If you're
        overriding this method you'll probably want something much simpler, eg:

        @classmethod
        def many_init(cls, *args, **kwargs):
            kwargs['child'] = cls()
            return CustomListSerializer(*args, **kwargs)
        """
        ...
    
    def to_internal_value(self, data):
        ...
    
    def to_representation(self, instance):
        ...
    
    def update(self, instance, validated_data):
        ...
    
    def create(self, validated_data):
        ...
    
    def save(self, **kwargs):
        ...
    
    def is_valid(self, *, raise_exception=...): # -> bool:
        ...
    
    @property
    def data(self): # -> empty | None:
        ...
    
    @property
    def errors(self): # -> ReturnList | list[Any] | ReturnDict | dict[Any, Any] | ErrorDetail:
        ...
    
    @property
    def validated_data(self): # -> empty | dict[Any, Any] | None:
        ...
    


class SerializerMetaclass(type):
    """
    This metaclass sets a dictionary named `_declared_fields` on the class.

    Any instances of `Field` included as attributes on either the class
    or on any of its superclasses will be include in the
    `_declared_fields` dictionary.
    """
    def __new__(cls, name, bases, attrs): # -> Self:
        ...
    


def as_serializer_error(exc): # -> dict[Any, list[ErrorDetail] | list[Any]] | dict[Any | list[Any] | dict[str, None] | bool | int | dict[str, str] | list[str] | str | None, list[ErrorDetail] | ReturnList | list[Any]] | dict[Any | list[Any] | dict[str, None] | bool | int | dict[str, str] | list[str] | str | None, list[ErrorDetail]]:
    ...

class Serializer(BaseSerializer, metaclass=SerializerMetaclass):
    default_error_messages = ...
    def set_value(self, dictionary, keys, value): # -> None:
        """
        Similar to Python's built in `dictionary[key] = value`,
        but takes a list of nested keys instead of a single key.

        set_value({'a': 1}, [], {'b': 2}) -> {'a': 1, 'b': 2}
        set_value({'a': 1}, ['x'], 2) -> {'a': 1, 'x': 2}
        set_value({'a': 1}, ['x', 'y'], 2) -> {'a': 1, 'x': {'y': 2}}
        """
        ...
    
    @cached_property
    def fields(self): # -> BindingDict:
        """
        A dictionary of {field_name: field_instance}.
        """
        ...
    
    def get_fields(self):
        """
        Returns a dictionary of {field_name: field_instance}.
        """
        ...
    
    def get_validators(self): # -> list[Any]:
        """
        Returns a list of validator callables.
        """
        ...
    
    def get_initial(self): # -> dict[Any, Any]:
        ...
    
    def get_value(self, dictionary): # -> MultiValueDict[Any, Any] | type[empty]:
        ...
    
    def run_validation(self, data=...): # -> empty | dict[Any, Any] | None:
        """
        We override the default `run_validation`, because the validation
        performed by validators and the `.validate()` method should
        be coerced into an error dictionary with a 'non_fields_error' key.
        """
        ...
    
    def run_validators(self, value): # -> None:
        """
        Add read_only fields with defaults to value before running validators.
        """
        ...
    
    def to_internal_value(self, data): # -> dict[Any, Any]:
        """
        Dict of native values <- Dict of primitive datatypes.
        """
        ...
    
    def to_representation(self, instance): # -> dict[Any, Any]:
        """
        Object instance -> Dict of primitive datatypes.
        """
        ...
    
    def validate(self, attrs):
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __iter__(self): # -> Generator[NestedBoundField | JSONBoundField | BoundField, Any, None]:
        ...
    
    def __getitem__(self, key): # -> NestedBoundField | JSONBoundField | BoundField:
        ...
    
    @property
    def data(self): # -> ReturnDict:
        ...
    
    @property
    def errors(self): # -> ReturnDict:
        ...
    


class ListSerializer(BaseSerializer):
    child = ...
    many = ...
    default_error_messages = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def get_initial(self): # -> list[Any]:
        ...
    
    def get_value(self, dictionary): # -> list[Any] | type[empty]:
        """
        Given the input dictionary, return the field value.
        """
        ...
    
    def run_validation(self, data=...): # -> empty | list[Any] | None:
        """
        We override the default `run_validation`, because the validation
        performed by validators and the `.validate()` method should
        be coerced into an error dictionary with a 'non_fields_error' key.
        """
        ...
    
    def run_child_validation(self, data):
        """
        Run validation on child serializer.
        You may need to override this method to support multiple updates. For example:

        self.child.instance = self.instance.get(pk=data['id'])
        self.child.initial_data = data
        return super().run_child_validation(data)
        """
        ...
    
    def to_internal_value(self, data): # -> list[Any]:
        """
        List of dicts of native values <- List of dicts of primitive datatypes.
        """
        ...
    
    def to_representation(self, data): # -> list[Any]:
        """
        List of object instances -> List of dicts of primitive datatypes.
        """
        ...
    
    def validate(self, attrs):
        ...
    
    def update(self, instance, validated_data):
        ...
    
    def create(self, validated_data): # -> list[Any]:
        ...
    
    def save(self, **kwargs): # -> list[Any]:
        """
        Save and return a list of object instances.
        """
        ...
    
    def is_valid(self, *, raise_exception=...): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def data(self): # -> ReturnList:
        ...
    
    @property
    def errors(self): # -> ReturnDict | ReturnList:
        ...
    


def raise_errors_on_nested_writes(method_name, serializer, validated_data): # -> None:
    """
    Give explicit errors when users attempt to pass writable nested data.

    If we don't do this explicitly they'd get a less helpful error when
    calling `.save()` on the serializer.

    We don't *automatically* support these sorts of nested writes because
    there are too many ambiguities to define a default behavior.

    Eg. Suppose we have a `UserSerializer` with a nested profile. How should
    we handle the case of an update, where the `profile` relationship does
    not exist? Any of the following might be valid:

    * Raise an application error.
    * Silently ignore the nested part of the update.
    * Automatically create a profile instance.
    """
    ...

class ModelSerializer(Serializer):
    """
    A `ModelSerializer` is just a regular `Serializer`, except that:

    * A set of default fields are automatically populated.
    * A set of default validators are automatically populated.
    * Default `.create()` and `.update()` implementations are provided.

    The process of automatically determining a set of serializer fields
    based on the model fields is reasonably complex, but you almost certainly
    don't need to dig into the implementation.

    If the `ModelSerializer` class *doesn't* generate the set of fields that
    you need you should either declare the extra/differing fields explicitly on
    the serializer class, or simply use a `Serializer` class.
    """
    serializer_field_mapping = ...
    if hasattr(models, 'JSONField'):
        ...
    if postgres_fields:
        ...
    serializer_related_field = PrimaryKeyRelatedField
    serializer_related_to_field = SlugRelatedField
    serializer_url_field = HyperlinkedIdentityField
    serializer_choice_field = ChoiceField
    url_field_name = ...
    def create(self, validated_data):
        """
        We have a bit of extra checking around this in order to provide
        descriptive messages when something goes wrong, but this method is
        essentially just:

            return ExampleModel.objects.create(**validated_data)

        If there are many to many fields present on the instance then they
        cannot be set until the model is instantiated, in which case the
        implementation is like so:

            example_relationship = validated_data.pop('example_relationship')
            instance = ExampleModel.objects.create(**validated_data)
            instance.example_relationship = example_relationship
            return instance

        The default implementation also does not handle nested relationships.
        If you want to support writable nested relationships you'll need
        to write an explicit `.create()` method.
        """
        ...
    
    def update(self, instance, validated_data):
        ...
    
    def get_fields(self): # -> dict[Any, Any]:
        """
        Return the dict of field names -> field instances that should be
        used for `self.fields` when instantiating the serializer.
        """
        ...
    
    def get_field_names(self, declared_fields, info): # -> Any | list[Any] | tuple[Any, ...]:
        """
        Returns the list of all field names that should be created when
        instantiating this serializer class. This is based on the default
        set of fields, but also takes into account the `Meta.fields` or
        `Meta.exclude` options if they have been specified.
        """
        ...
    
    def get_default_field_names(self, declared_fields, model_info): # -> list[Any]:
        """
        Return the default list of field names that will be used if the
        `Meta.fields` option is not specified.
        """
        ...
    
    def build_field(self, field_name, info, model_class, nested_depth): # -> tuple[type[PrimaryKeyRelatedField] | Any | type[ModelField] | type[CharField] | type[ChoiceField], Any] | tuple[type[SlugRelatedField] | type[PrimaryKeyRelatedField] | type[<subclass of SlugRelatedField and HyperlinkedRelatedField>] | type[<subclass of PrimaryKeyRelatedField and HyperlinkedRelatedField>], dict[str, Any | str]] | tuple[type[NestedSerializer], dict[str, bool]] | tuple[type[ReadOnlyField], dict[Any, Any]] | tuple[serializer_url_field, dict[str, str]]:
        """
        Return a two tuple of (cls, kwargs) to build a serializer field with.
        """
        ...
    
    def build_standard_field(self, field_name, model_field): # -> tuple[type[PrimaryKeyRelatedField] | Any | type[ModelField] | type[CharField] | type[ChoiceField], Any]:
        """
        Create regular model fields.
        """
        ...
    
    def build_relational_field(self, field_name, relation_info): # -> tuple[type[SlugRelatedField] | type[PrimaryKeyRelatedField] | type[<subclass of SlugRelatedField and HyperlinkedRelatedField>] | type[<subclass of PrimaryKeyRelatedField and HyperlinkedRelatedField>], dict[str, Any | str]]:
        """
        Create fields for forward and reverse relationships.
        """
        ...
    
    def build_nested_field(self, field_name, relation_info, nested_depth): # -> tuple[type[NestedSerializer], dict[str, bool]]:
        """
        Create nested fields for forward and reverse relationships.
        """
        class NestedSerializer(ModelSerializer):
            class Meta:
                ...
            
            
        
        
    
    def build_property_field(self, field_name, model_class): # -> tuple[type[ReadOnlyField], dict[Any, Any]]:
        """
        Create a read only field for model methods and properties.
        """
        ...
    
    def build_url_field(self, field_name, model_class): # -> tuple[serializer_url_field, dict[str, str]]:
        """
        Create a field representing the object's own URL.
        """
        ...
    
    def build_unknown_field(self, field_name, model_class):
        """
        Raise an error on any unknown fields.
        """
        ...
    
    def include_extra_kwargs(self, kwargs, extra_kwargs):
        """
        Include any 'extra_kwargs' that have been included for this field,
        possibly removing any incompatible existing keyword arguments.
        """
        ...
    
    def get_extra_kwargs(self): # -> Any | dict[Any, Any]:
        """
        Return a dictionary mapping field names to a dictionary of
        additional keyword arguments.
        """
        ...
    
    def get_unique_together_constraints(self, model): # -> Generator[tuple[Any, Any], Any, None]:
        """
        Returns iterator of (fields, queryset), each entry describes an unique together
        constraint on `fields` in `queryset`.
        """
        ...
    
    def get_uniqueness_extra_kwargs(self, field_names, declared_fields, extra_kwargs): # -> tuple[Any, dict[Any, Any]]:
        """
        Return any additional field options that need to be included as a
        result of uniqueness constraints on the model. This is returned as
        a two-tuple of:

        ('dict of updated extra kwargs', 'mapping of hidden fields')
        """
        ...
    
    def get_validators(self): # -> list[Any]:
        """
        Determine the set of validators to use when instantiating serializer.
        """
        ...
    
    def get_unique_together_validators(self): # -> list[Any]:
        """
        Determine a default set of validators for any unique_together constraints.
        """
        ...
    
    def get_unique_for_date_validators(self): # -> list[Any]:
        """
        Determine a default set of validators for the following constraints:

        * unique_for_date
        * unique_for_month
        * unique_for_year
        """
        ...
    


class HyperlinkedModelSerializer(ModelSerializer):
    """
    A type of `ModelSerializer` that uses hyperlinked relationships instead
    of primary key relationships. Specifically:

    * A 'url' field is included instead of the 'id' field.
    * Relationships to other instances are hyperlinks, instead of primary keys.
    """
    serializer_related_field = HyperlinkedRelatedField
    def get_default_field_names(self, declared_fields, model_info): # -> list[Any | list[Any] | dict[str, None] | bool | int | dict[str, str] | list[str] | str | None]:
        """
        Return the default list of field names that will be used if the
        `Meta.fields` option is not specified.
        """
        ...
    
    def build_nested_field(self, field_name, relation_info, nested_depth): # -> tuple[type[NestedSerializer], dict[str, bool]]:
        """
        Create nested fields for forward and reverse relationships.
        """
        class NestedSerializer(HyperlinkedModelSerializer):
            class Meta:
                ...
            
            
        
        
    


